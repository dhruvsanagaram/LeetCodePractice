#1/2/23 - Longest Common Prefix - Strings - Easy
class Solution(object):
    def longestCommonPrefix(self, strs):
        if(len(strs) == 0):
            return ""
        prefix = strs[0]
        for i in range(len(strs)):
            print(strs[i].find(prefix))
            while(strs[i].find(prefix) != 0):
                prefix = prefix[0:len(prefix)-1]
                if(prefix == ""):
                    return ""
        return prefix

#1/3/23 - Remove Duplicates from Sorted Array - Arrays - Essay
class Solution(object):
    def removeDuplicates(self, nums):
        # my_dict = dict()
        # for i in range(len(nums)):
        #     if(nums[i] in my_dict.keys()):
        #         my_dict[nums[i]] += 1
        #     else:
        #         my_dict[nums[i]] = 1
        # nums = my_dict.keys()
        # return len(my_dict.keys()) 
        if len(nums) == 0:
            return 0
        
        addIdx = 1
        for i in range (len(nums)-1):
            if(nums[i] < nums[i+1]):
                nums[addIdx] = nums[i+1]
                addIdx+=1
        return addIdx

#1/4/23 - Merge Two Sorted Lists - LinkedLists - Easy
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        if(list1.val < list2.val){
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        }
        else{
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}

#1/6/23 - Valid Parentheses - Stacks - Easy
class Solution {
    public boolean isValid(String s) {
        System.out.println(s);
        Stack<Character> parentheses = new Stack<Character>();
        String tempStr = new String();
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '['){
                parentheses.push(s.charAt(i));
            }
            else{
                if(s.charAt(i) == ')' && (parentheses.isEmpty() 
                    || parentheses.pop() != '(')){
                    return false;
                }
                if(s.charAt(i) == ']' && (parentheses.isEmpty() 
                    || parentheses.pop() != '[')){
                    return false;
                }
                if(s.charAt(i) == '}' && (parentheses.isEmpty() 
                    || parentheses.pop() != '{')){
                    return false;
                }
            }
        }
        if(parentheses.isEmpty()){
            return true;
        }
        return false;
        /*
        System.out.println(s);
        Stack<Character> parentheses = new Stack<Character>();
        String tempStr = new String();
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '['){
                parentheses.push(s.charAt(i));
            }
            else{
                if(s.charAt(i) == ')'){
                    int j = i;
                    while(j >= 0 && s.charAt(j) != '('){
                        tempStr += parentheses.pop();
                        j--;
                    }
                    if(j < 0){
                        return false;
                    }
                    System.out.println(parentheses);
                    if(!parentheses.isEmpty()){
                        parentheses.pop();  
                    }
                    while(j != i){
                        System.out.println(tempStr);
                        parentheses.push(tempStr.charAt(tempStr.length()-1-i));
                        j++;
                    }
                    tempStr = "";
                }
                if(s.charAt(i) == ']'){
                    int j = i;
                    while(j >= 0 && s.charAt(j) != '['){
                        tempStr += parentheses.pop();
                        j--;
                    }
                    if(j < 0){
                        return false;
                    }
                    if(!parentheses.isEmpty()){
                        parentheses.pop();  
                    }
                    while(j != i){
                        parentheses.push(tempStr.charAt(tempStr.length()-1-i));
                        j++;
                    }
                    tempStr = "";
                }
                if(s.charAt(i) == '}'){
                    int j = i;
                    while(j >= 0 && s.charAt(j) != '{'){
                        tempStr += parentheses.pop();
                        j--;
                    }
                    if(j < 0){
                        return false;
                    }
                    if(!parentheses.isEmpty()){
                        parentheses.pop();  
                    }                    while(j != i){
                        parentheses.push(tempStr.charAt(tempStr.length()-1-i));
                        j++;
                    }
                    tempStr = "";
                }
            }
        }
        if(parentheses.isEmpty()){
            return true;
        }
        return false;
    }
    */
}
}

#1/8/23 - Remove Element - Arrays - Easy
class Solution {
    public int removeElement(int[] nums, int val) {
        int c = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != val){
                nums[c] = nums[i];
                c++;
            }
        }
        return c;
    }
}

#1/8/23 - Search Insert Position - Arrays - Easy
class Solution {
    public int searchInsert(int[] nums, int target) {
        if(nums[0] >= target){
            return 0;
        }
        for(int i = 1; i <= nums.length-1; i++){
            if(nums[i] == target){
                return i;
            }
            if(nums[i-1] < target && target < nums[i]){
                return i;
            }
            if(i+1 != nums.length && nums[i-1] < target && target < nums[i+1]){
                return i+1;
            }
        }
        return nums.length;
    }
}

#1/9/23 - Preorder Traversal - Trees - Easy
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
        list = traversalHelper(list, root);
        return list;
    }

    public List<Integer> traversalHelper(List<Integer> list, TreeNode root){
        if(root == null){
            return list;
        }
        list.add(root.val);
        traversalHelper(list, root.left);
        traversalHelper(list, root.right);
        return list;
    }
}

#1/11/23 - Add Binary - Strings - Easy
import java.math.*;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger a_new = new BigInteger(a, 2);
        return a_new.add(new BigInteger(b, 2)).toString(2);
        /*
        String sum = "";
        int carry = 0;
        int numA = 0;
        int numB = 0;

        for(int i = a.length()-1; i>=0; i--){
            try{
                numA = Integer.parseInt(a.charAt(i) + "");
            }
            catch(IndexOutOfBoundsException e){
                numA = 0;
            }

            System.out.print(numA + " ");

            try{
                numB = Integer.parseInt(b.charAt(i) + "");
            }
            catch(IndexOutOfBoundsException e){
                numB = 0;
            }

            System.out.println(numB + " ");

            if(carry == 0){
                if(numA == 1 && numB == 1){
                    carry = 1;
                    sum += '0';
                }
                if(numA == 0 && numB == 0){
                    carry = 0;
                    sum += '0';
                }
                if((numA == 0 && numB == 1) 
                    || (numA == 1 && numB == 0))
                {
                    carry = 0;
                    sum += '1';
                }
            }

            if(carry == 1){
                if(numA == 1 && numB == 1){
                    carry = 1;
                    sum += '1';
                }
                if(numA == 0 && numB == 0){
                    carry = 0;
                    sum += '1';
                }
                if((numA == 0 && numB == 1) 
                    || (numA == 1 && numB == 0))
                {
                    carry = 1;
                    sum += '0';
                }
            }
            System.out.println(sum);
        }
        return null;
        */
    }
}

#2/1/23 - Maximum Ascending Subarray Sum - Arrays - Easy
class Solution {
    public int maxAscendingSum(int[] nums) {
        int maxSum = nums[0];
        int i = 1;
        int curSum = nums[0];
        while(i < nums.length){
            System.out.println("Cur:" + nums[i]);
            System.out.println("Before:" + nums[i-1]);
            System.out.println("CurSum:" + curSum);
            System.out.println("MaxSum:"+maxSum);
            System.out.println();
            if(nums[i] <= nums[i-1]){
                if(curSum > maxSum){
                    maxSum = curSum;
                }
                curSum = 0;
            }
            curSum += nums[i];
            i++;
        }
        if(maxSum < curSum){
            maxSum = curSum;
        }
        return maxSum;
    }
}

#2/2/23 - Remove Duplicates - LinkedList - Easy
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        HashMap<Integer, Integer> freq= new HashMap<Integer, Integer>();
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode bef = dummy;
        ListNode cur = head;
        while(cur != null){
            Integer count = freq.get(cur.val);

            if(count == null){
                freq.put(cur.val, 1);
                bef = bef.next;
            } 
            else{
                bef.next = cur.next;
            }
            cur = cur.next;
        }
        return head;
    }
}

#2/8/23 - Squaring a Sorted Array - Array - Easy
class Solution {
    public int[] sortedSquares(int[] nums) {
       int[] result = new int[nums.length];
       int left = 0;
       int right = nums.length-1;
       int p = nums.length-1;
       while(left <= right){
           if(Math.abs(nums[left]) > Math.abs(nums[right])){
               result[p] = nums[left]*nums[left];
               left++;
           }
           else{
               result[p] = nums[right]*nums[right];
               right--;
           }
           p--;
       } 
       return result;
    }
}